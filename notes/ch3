OBJECTIVES
>> Demonstrate how 8-bit and 16-bit unsigned numbers are added in the 80x86
>> Convert data of any forms: ASCII, packed BCD, or unpacked BCD
>> Explain the effect of unsigned arithmetic instructions on the flag register

UNSIGNED ADDITION AND SUBTRACTION
  -Addition of unsigned numbers
     ADD dest, src  ; dest=dest + src
     ADC dest, src  ; dest=dest + src + CF "the value of CF before the current operation is added not after dest + src"
     the dest can be a register or memory, the src can be a register or memory or immeditate value
     remember that 8086 never allow memory to memory for any operations.
     In addition operations there are two cases you want to add oprands in
     if the oprands are of the same size as the registers or in other words the oprands
     can fit inside any register you have, the second case the oprands can not fit
     in any register which means they are more than 2 bytes numbers

    -Case1: Addition of word or byte data
     Here we can just use the AX/AL as an acumilator and loop throw all the word/byte data and add them with AX/AL
     the problem with this simple solutoin is it is not correct in general. if the summation of the data is larger than the size
     of the accumlator used then there are some data lost because we ignore the carry out of each opration
     the solution to this is to use an accumlator and another register to accumlate the carry out of each ADD opration this is done
     by the adding the CF. see the example

     BACK: ADD AX, [SI]
           ADC BX, 00H
           INC SI
           DEC CX
           JNZ BACK;

     here the BX is used to accumlate the carry "ADC BX, 00H => BX = BX + 00H + CF = BX + CF"  

    -Case2: Addition of multiword numbers
     In order to add multiword data one must partition the data into register size chuncks and add them in chuncks
     it is obvious that the carry must be add from chunck to chunck in order to get the correct result. so if you have
     two 8-byte number to add them define them with DQ directive and add 2 bytes by 2 bytes here is an algorithm
     store the oprands in SI, and DI and the result in BX, clear the carry "CLC" mov from SI the first 2-bytes to AX
     ADC AX, [DI] store the sum in [BX] -> mov [BX], AX. the ADC will get the correct result.
     IMPORTANT: if you use the above the alogrithm do not use any addition in after the ADC until the loop finish
     NOTE THAT DEC AND INC DOES NOT AFFECT THE CF EVEN IF INC BX, and BX WAS FFH, THE SAME FOR DEC.
  
  -Subtraction of unsigned numbers
     SUB dest, source ; dest = dest - source
     How the CPU do that?
     The CPU use the same add circuit to perform the subtraction which is weired but more effiecint
     1- the source converted to its 2'complement form
     2- the dest is add to 2'complement of source and the result is stored in dest
     3- the carry flag is inverted.
     it will be wrong if the programmer check the sign flag to know if the result is negative or positive
     one should check the carry flag if it is 0 then the result is positive and the dest is greater than or equal to the source
     if the carry flag is 1 then the result is in 2'complement form and the dest is smaller than the source.
     we can use NOT followed by INC to convert the result back to normal representaion.
     
     SBB des, source ; dest = dest - source - CF
     this is used when subtracting multiword data. the same is done as adding multiword data the lower bytes data
     are first subtracted and if the carry is set it will be subtracted from the higher bytes.
  PTR DIRECTIVE
     the PTR directive is used to direct the assembler to use certain size instead the one that assign with the data
     for example if you define DATA1 DW 235FH. If you then whant to get the data from DATA1 and put it in AL
     if you use MOV AL, DATA1. this gives an error because the sizes must match. to get around this use
     MOV AL, BYTE PTR DATA1 + {offset} this will give you only the first byte in DATA1.
        

UNISINGED MULTIPLICATION AND DIVISION
    8086 has this feature that 8085 does not have which is it now supprots multipilcation and division
    in those operation the AX, AH, AL, DX are used.
    - Multiplication
      in multiplication with 8,16-bit registers we have 3 cases
      1- 8-bit * 8-bit
         in this case one of the oprand must be in AL and the other can be in a register or in memory
         MOV AL, OP1
         MUL OP1
         MOV RESULT, AX
         THE RESULT IS SAVED IN AX.
         if you use register indirect addressing mode the oprand size must be specified with PTR directive.because
         the asselbler will not know if you need the byte or the word pointed to by the register.
      2- 16-bit * 16-bit
         one of the oprand must be in AX and the other can be register or in memory
         MOV AX, 1253H
         MOV BX, 1534H
         MUL BX
         here we know the largest number can be as output from two unsigned 16-bit numbers is (2^(16)-1)^2 = 2^(32)-2^(17)+1
         this number can only be stored in 32 bit number. so how we do that?
         the DX will help AX to store this big number. DX will hold higher bits and AX lower bits
         NOTE IN MULTIPLICATION IMMEDIATE DATA MUST BE IN A REGISTER.
      3- 16-bit * 8-bit result in DXAX
         one must be in AL and AH MUST BE ZERO The other can be in memory or in a register.
         Note that this is much similar to word * word the trick here is just use lower bits from AX and
         set the higher bits to zero and then multibly by a 16-bit value. from this the 8-bit oprand must be in AL.

    - Division
      we have four cases
      1- word/byte
         The word data must be in AX and the second oprand can not be an immediate value it must be in a register or in memory
         the result is quotient is stored in AL and the remainder in AH, NOTE THAT THE MAXIMUM QUOTIENT IS FFH.
      2- byte/byte
         the same as word/byte but the trick is to set AL as the numerator and set AH to 0, then use div with the denomenator.
         the denominator must be a register or in memory
      3- double word/ word
         The numrator is stored in DXAX as DX has the higher bits and AX has lower order bits the denominator must be word sized
         and stored in memory or in register. the qoutient is stored in AX and the reminder is stored in DX.
      4- word / word
         set DX to 0 and you get the trick here.

      But How does the CPU knows if the DX has to be used either in multiplication or in division? if we talk a closer look for the cases
      the can compressed in only two cases and the parameter that the CPU use to choose the disision is just the size of the oprand to the
      instruction. for example in if DIV WORD_DATA then the CPU will automaticly knows that it must use DXAX and divide by WORD_DATA.
      if DIV BYTE_DATA  then the CPU will only use AX as the numerator. this explains why we use the trick above and set the higher order bits
      to zero to have more cases in division.
      
LOGICAL INSTRUCTIONS

    -AND dest, source 
     dest can be register or in memory, dest can be immediate or register or in memory
     this instruction will perform bitwise AND between the dest and the source and will place the result in dest.
     AND will set the CF and OF autmatically to zero, and ZF, SF, PF will set according to the restul.
     we can use AND to know if the register contains zero by ANDing it with itself if the register contains zero
     then the ZF flag is set. then we can perform acctions accroding to that like not divide by it if it is zero.

    -OR dest, source
     The oprandes are ORed and the result is stored in dest. this can be used to set bits to one.
     the flags will be affected as AND get affected. also can be used to check for zero by oring the oprand to itself

    -XOR dest, source
     has the same flag and oprand rules as OR and AND instructions
     but it has interseting applications. 
     -it can be used to test if the two oprands are equal
     -it also can be used to clear the contents of a register
     -it can be used to toggle bits in the dest. with bits equal 1 in source
      so if source = 0000 0001 then XOR dest, source . will only toggle the first bit in dest and keep rest the same.

    - SHIFT OPRATIONS (SHL, SHR) (logical shift)
      the shift dest can be in a register or in memory but not immediate. the source can only be 1 or a CL
      use 1 if you will shift one time, CL if you will shift many.
     -SHL dest, source
      the destionation is sihfted bit by bit from the MSB and zero bits entered from the right as we shift the MSG per shift
      is stored in CF. you may immagine the CF as if a check room for each bit that leave the data. as each bit leave it must
      go to check room first until another bit has to leave the first one goes out and the most recently leaving will be in CF and so on.
      The flag affected are all of CF, OF, SF, PF, ZF the last four changed according throw the new restul. note that the result is 
      stored in the dest.
     -SHR
      is the same as SHL but the check room is now in the right of the data and zeros comeing from left and leaving from right to CF.
    
     -CMP op1, op2
      op1 can be in a register or in memory and op2 can be register or in memory or immediate.
      this OPERATION DOES NOT AFFECT ANY OF OP1, OP2 IT ONLY AFFECTS THE FLAG REGISTER. see tables.
      it subtracts op1 - op2 and the flag is only affected by the resul of this subtraction
      JA and JB can be used after comparsion if op1>op2 JA , if op1<op2 JB and JZ if op1=op2

     -Rotations
        the number of rotations if it is one then can be used as immediate if not it must be in CL
        The oprand "data" can be in a register or in memory
        to remember what is the direction of the data. if R is the last letter in the instruction then CF is at the right and the data 
        goes from left to right
        if the last letter is L then the CF is set left to the data and the direction is the rotaion happen from right to left

      -normal rotaions
       -ROR rotate to the right
        the LSB is copied to the CF then the data is shifted by one and the CF is copied to the MSB the CF acts as a placeholder
       -ROL rotate to the left
        the MSB is copied to the CF the data is shifted to the left by one then the CF is copied to the LSB.

      -with carry rotations
       -RCR
        The carry flag is part from the data now.
        the LSB goes to the carry and the old carry goes to the MSB. and so on, this happens per rotation
       -RCL
        The MSB is goes to the carry and the old carry goes to the LSB. happens also per rotatoin.

