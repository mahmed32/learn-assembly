>> Explain the difference between Assembly language instructions and 
   pseudo-instructions
>> Identify the segments of an Assembly language program
>> Code simple Assembly language instructions
>> Assemble, link, and run a simple Assembly language program
>> Code control transfer instructions such as conditional and unconditional
   umbs and call instructinos
>> Code Assembly language data directives for binary, hex, decima, or ASCII data
>> Write and Assembly language program using either the full segment definition
   or the simplified segment definition
>> Explain the difference between COM andEXE files and list the advanctages of each

DIRECTIVES AND A SAMPLE PROGRAM

    General form of a line in assembly
    [lable:] mnemonic [oprands,] [;comment]

    Lables are just a name for the line. we use lables to assign lines of code
    to certain strings that can be easly used. a lable my refrence a CPU instruction
    or an assembly directive. A directive is just an instruction but NOT for the CPU
    it is for the ASSEMBLER. the assembler use these directive to organize the program
    and how it should translate the instructions into machine code. A lable for a directive
    does not has to end with a colon while if it is for a line that refrences a CPU instruction
    it must end with a colon "with no spaces". A lable may be as long as 31 character long.
    
    mnemonic and oprands. mnemonics are instructions for the CPU to execute. the assembler translate
    them into machine codes or opcodes. the oprands are depending on the instruction or the mnemonic.
    the mnemonic and oprands can be a directive.

    the comments are optional.

    Model definition
    the .MODEL directive direct the assembler to use a spesific memory model
    avalibale models are TINY, SMALL, MEDIUM, LARGE, COMPACT, HUGE. the most widly
    used is the SMALL model. so when you begin your source code it must begin
    with the .MODEL directive with SMALL as its oprand
    typical line >> .MODEL SMALL

    Segmetn definition
    As we now know the CPU has 4 segment registers those registers point to
    places in memory that contains different type of data.Every line in assembly
    language must coresspond to one the 4 segments. we can use the directive
    to mark the begin of one segment and the end of the current. typically we
    begin after the model directive by the .STACK [ammount of memory in bytes]
    which tells the assembler I want those ammount of memory in the stack to be
    avalibale to my program during execution. note that the programmer does not
    care where is the STACK segment begin it is the job for the OS to find a place
    in memory set aside the amount of memory for my program and fill the SS register and
    SI with the proper information about my stack address. 
    
    after the stack segment we direct the assembler to the begining of the data segment
    The data segment is used for the memory to be accessed during execution
    .DATA directive is followed by lable for the data and another directive for the size of
    required to those data and optional initial value. It is the job for the programmer to
    fill the DS register with the address of the data segment. This is achived by putting
    those line on the begining of your program (your main procedure)
    MOV AX, @DATA ; DATA CONTAINS THE ADDRESS OF THE DATA SEGMENT
    MOV DS, AX    ; THIS FILLS THE DS WITH APPROPRIATE VALUES

    after the data segment the actual fun begins the code segment definition
    by the .CODE directive every line after the code directive is part of the code
    segment. the code segment is partiointed optionaly by procedures. A procuder is
    a group of instructions that do specific job or function. The program must start
    with a procedure as its entry point. here comes another directive in the show
    the LABLE_NAME PROC [FAR, NEAR]. the entry point must be FAR (this is required by the OS)
    we will know what is the difference between FAR and NEAR in up comming sections
    but for now the entry point must be far. the entry point must also ended by another
    directive ENDP LABEL_NAME. note that the LABLE_NAME must match each other for the same
    procedure. but this is not enough to know which procedure is the entry point since more
    than one procedure may be FAR the END ENTRY_POINT_LABLE_NAME must be the last line
    in the code segment.the CS register and IP are filled automaticlly by the OS.

    A template for your assembly programs

    ;about the program what it does and who is the author
    .MODEL SMALL
    .STACK 32   ;ALLOCATE 32 BYTES FOR THE STACK
    .DATA
    ;
    ;DEFINE YOUR DATA HERE
    ;
    .CODE
ENTRY_POINT PROC FAR
    MOV AX, @DATA
    MOV DS, AX
    ;
    ;
    ; PLACE YOUR CODE HERE
    ;
    ;
    MOV AH, 4CH  ; SET UP TO
    INT 21H      ; RETURN TO DOS
ENTRY_POINT ENDP
    END ENTRY_POINT


    Analysis of program 2-2
    Another important directive is ORG which is used inside the segments
    to set the offset of the next instruction or data.
    so .DATA followed by ORG 10H will set the offset to be DS:0010H.

    When using letter as the first digit in a hex number write 0 before it
    to not confuse the assembler and tell it this is a number and not a letter.
    
ONTROL TRANSFER INSTRUCTIONS {CALL, JUMP}
    what is the difference between FAR AND NEAR?
    previously I told you to make the entry point of your program FAR but why??
    now is the time for the answer. if we return to the basics of the CS and IP
    we agree on what follows "Every instruction has a physical address and every
    physical address has a crossponding logical address this is CS:IP in the case
    of instructions". so to transfer the control in your program which means you
    make another code to be executed instead of the next instruction you must update
    the address of the instruction to be executed. if the instruction to be executed
    is "near" the current one which means both have the same base address or in other words
    both are in the same segment this tranfer is a near transfer. if both the CS and IP have to
    be updated then this jump is a FAR jump. I think this makes perfect sence.
    but I still not answer you why the entry point if FAR. With what we see about FAR jumps
    there must be a caller to the entry point and this caller is FAR from my entry point
    this caller is the OS in your machine. which is logicaly write sence the OS must not run
    inside your code segment.

    Conditional jumps
    uses the the flag register (see tables for complete set of the those jumbs)

    Short jumps 
    A short jump or a conditional jump is a jump that happen to transfer the control
    to a lable that in the RANGE OF 127 AND -128 which means that the conditional jump
    instruction is a two byte instruction with the first byte as the opcode and the second
    is the jump offset which can be from 00h to FFh any attempt to jump into a lable that is 
    out of this range the assembler will produce an out of jump range error.
    to calclute the next IP after the jump add the offset with the IP of the next instruction.
    this is how the the CPU know where to go.

    Unconditional jumps
    has the form JMP {Far, near, short} {PTR label, any address mode, lable}
    it jump unconditionaly to the lable specified. it has three forms
    JMP SHORT LABLE 
    this form is like the short jumps which has opcode and offset in two bytes
    this mode is effient because it uses only 2 bytes.
    JMP NEAR {ADDRESSING MODE}
    this is like the short one but it use 3 bytes for the opcode and the offset 
    the offset is 2 bytes which ranges from -32768 and +32767 
    until now the jumps affects only the IP.
    JUMP FAR PTR LABLE
    here both the CS and the IP are affected and the control ransfers to another segment
    

    CALL STATEMENTS
    CALL is another instruction to tranfer the control to another code block
    it may be FAR or NEAR. but unlike jumping to lables CALL jumps to procesdures
    each procedure must define if its a FAR or NEAR procedure. But why?
    the reson is the CPU unlike jumps which not comming back to where it stops
    in CALL the control must be back to the NEXT instruction after the CALL
    so there may be some way to store the IP and then change it to the procedure
    and then return back the first IP. this is done by the stack. Whenever you use
    CALL the IP of the next instruction is pushed into the stack. after the procedure
    finshes its work it must use RET instruction which as you might guess will pop
    the IP from the stack and the BIU will begin fetching from the new IP which is the old
    by the way:). NOTE if you push any thing into the stack inside the called procedure
    you must pop it before the RET, otherwise the IP will contain what ever poped which
    will continue blindly executing. this is very dangours which may destroy your entire system.
    if the procedure defines itself as FAR it gives the direction to the assembeler to change the opcode
    for the CALL instruction. in this case both the CS and IP will be pushed into the stack.
    and after RET both will be poped.
    TODO: see what is the order in stack that CS and IP are pushed in the case of FAR jump.

    the default for the PROC is NEAR.

    RULES FOR NAMING IN ASSEMBLY
    see tables/naming_rules.png
    
